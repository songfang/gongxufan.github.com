<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>gongxufan@Github</title>
    <meta name="description" content="潇湘往事的个人技术博客，这里记录了我平时工作和学习的点滴．坚持写博客积累知识，提高自己．">
    <meta name="keywords" content="我,gongxufan,Blog,Github">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/pygments/default.css">
    <link rel="stylesheet" href="/css/font-awesome.css">
    <link rel="canonical" href="http://gongxufan.github.io/">
    <script src="/js/jquery.min.js"></script>
<body>

<header class="site-header">

    <div class="wrapper">

        <a class="site-title" href="/">潇湘往事的Blog</a>

        <nav class="site-nav">
            <a href="#" class="menu-icon">
                <svg viewBox="0 0 18 15">
                    <path fill="#424242"
                          d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242"
                          d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242"
                          d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </a>

            <div class="trigger">
                <a class="page-link" href="/about.html">关于我</a>
                <a class="page-link" href="/">返回</a>
            </div>
        </nav>

    </div>

</header>


<div class="page-content">
    <div class="wrapper">
        <div class="post">

            <header class="post-header">
                <h1 class="post-title">探索Rust的所有权系统</h1>
                <p class="post-meta">2015/5/6</p>
                <p class="post-meta">原文地址：<a target="_blank" href="http://nercury.github.io/rust/guide/2015/01/19/ownership.html">http://nercury.github.io/rust/guide/2015/01/19/ownership.html</a></p>
            </header>

            <article class="post-content">
                <p class="post-meta">This two-part guide is for a reader who knows basic syntax and
                    building blocks of <strong>Rust</strong> but does not quite grasp how the
                    <strong>ownership</strong> and <strong>borrowing</strong> works.</p>
                <p>这个由两部分(注：ownership和borrowing)组成的指南，是给那些知道<strong>Rust</strong>的基本语法,能像堆积木一样编写<strong>Rust</strong>代码，
                    但是还不能完全领悟<strong>ownership</strong> 和 <strong>borrowing</strong>是怎样运作的人阅读的．</p>

                <p class="post-meta">We will start <em>very</em> simple, and then gradually increase
                    complexity at a slow pace, exploring and discussing every new bit
                    of detail. This guide will assume a <em>very</em>
                    basic familiarity with <code>let</code>, <code>fn</code>, <code>struct</code>, <code>trait</code> and
                    <code>impl</code> constructs.</p>
                <p>我们将从非常简单的地方开始然后平缓的逐渐增加其复杂度，探索和讨论每一个新细节． 这篇指南假设你对 <code>let</code>, <code>fn</code>, <code>struct</code>, <code>trait</code> and
                    <code>impl</code> 的概念有基本的熟悉.</p>


                <p class="post-meta">Our goal is to learn how to write a new Rust program
                    and not hit any walls related to ownership or borrowing.</p>
                <p>我们的目标是学习怎么写一个新的Rust程序，而不会涉及ownership和borrowing的方方面面.</p>

                <h4 id="in-this-first-ownership-part"><a class="header-link" href="#in-this-first-ownership-part"><i class="fa fa-link"></i></a>首先是, <em>ownership</em> 部分:</h4>

                <ul>
                    <li><a href="#prerequisites---what-you-already-know">简短介绍</a>后</li>
                    <li>我们将学习 <a href="#copy-trait">Copy Traits</a>, 然后</li>
                    <li>关于 <a href="#ownership">Immutable</a></li>
                    <li>和 <a href="#mutable-ownership">Mutable</a> 的ownership 规则.</li>
                    <li>然后我们着眼于 <a href="#the-power-of-ownership-system">Ownership系统的强大之处:</a></li>
                    <li> <a href="#memory-allocation">内存管理</a>方面,</li>
                    <li><a href="#garbage-collection">垃圾回收</a>方面</li>
                    <li> <a href="#concurrency">并发性</a>方面.</li>
                </ul>

                <h3 id="prerequisites---what-you-already-know"><a class="header-link" href="#prerequisites---what-you-already-know"><i class="fa fa-link"></i></a>预备知识 - 你需要知道的</h3>

                <p class="post-meta">Scope/stack based memory management is quite intuitive, because we are very
                    familiar with it.</p>
                <p>基于作用域/栈的内存管理对我们来说是相当自然的, 因为我们对它已经非常熟悉了.</p>

                <p class="post-meta">What happens to <code>i</code> at the end of the <code>main</code> function?</p>
                <p>在<code>main</code>函数结束的时候<code>i</code>会发生什么?</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
                    <span class="p">}</span></code></pre></div>

                <p class="post-meta">It goes out of scope and dies, right?</p>
                <p>它超出了作用域结束生命周期了, 对吧?</p>

                <p class="post-meta">If we pass this <code>i</code> to another function <code>foo</code>, how
                    many times will it “die”?</p>
                <p>如果我们把这个 <code>i</code> 传递到另外一个函数 <code>foo</code>, 它的生命周期会结束多少次?</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">i64</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// another function foo</span>
                    <span class="c1">// something</span>
                    <span class="p">}</span>

                    <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
                    <span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// call function foo</span>
                    <span class="p">}</span></code></pre></div>

                <p class="post-meta">Well, it will “die” twice. First, at the end of <code>foo</code>,
                    and then at the end of <code>main</code>. If you modify it in <code>foo</code>,
                    <strong>it will not affect</strong> the value in <code>main</code>.</p>

                <p>很好, 它的生命周期结束了两次. 首先, 是在<code>foo</code>函数的结尾,
                    然后在<code>main</code>函数的结尾. 如果你在<code>foo</code>函数中改变它的值,
                    <strong>这不会影响</strong>它在<code>main</code>函数中的值.</p>


                <p class="post-meta">The value <strong>gets copied</strong> at the call of <code>foo(i)</code>.</p>
                <p>那个值在<code>foo(i)</code>函数的调用中 <strong>被复制</strong>.</p>

                <p class="post-meta">In Rust, like in C++ (and some other languages), it is possible to use
                    your own type instead of integer. The value will be allocated on current stack
                    and it will be destroyed (the destructor will be called) when it goes
                    out of scope.</p>

                <p>和C++ (以及其他语言)一样,  Rust也允许你使用自己的类型而不仅仅是整型. 这个值会在当前的栈上被分配，
                    然后在它超出自己的作用域的时候会被销毁(析构器将被调用).</p>

                <p class="post-meta">However, the Rust compiler follows different <em>ownership</em> rules, unless
                    type implements a <code>Copy</code> trait. Therefore we need to talk about the <code>Copy</code>
                    trait first, and get it out of the way.</p>

                <p>然而，Rust编译器遵循不同的 <em>ownership</em> 规则, 除非这个类型实现<code>Copy</code> trait(特性).
                   因此我们首先需要讨论 <code>Copy</code>trait, 并学习它.</p>

                <h2 id="copy-trait"><a class="header-link" href="#copy-trait"><i class="fa fa-link"></i></a>Copy Trait</h2>

                <p>The <code>Copy</code> trait makes the type to behave in a
                    very familiar way: its bits will be copied to another
                    location for every assignment or use as function argument.
                    Implementing it allows your data to be used like a built-in integer.</p>

                <p>The built-in machine type <code>i64</code> (one kind of integer) implements this
                    trait, like <a href="http://doc.rust-lang.org/std/marker/trait.Copy.html">many others</a>.</p>

                <p>If we have a struct <code>Info</code>, we can make it copy-able by implementing
                    <code>Copy</code> this way:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Info</span> <span class="p">{</span>
                    <span class="n">value</span><span class="o">:</span> <span class="kt">i64</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="k">impl</span> <span class="n">Copy</span> <span class="k">for</span> <span class="n">Info</span> <span class="p">{}</span></code></pre></div>

                <p>Or, equivalently, add <code>#[derive(Copy)]</code> attribute for it:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Copy)]</span>
                    <span class="k">struct</span> <span class="n">Info</span> <span class="p">{</span>
                    <span class="n">value</span><span class="o">:</span> <span class="kt">i64</span><span class="p">,</span>
                    <span class="p">}</span></code></pre></div>

                <p>The types <strong>without</strong> this trait will be <strong>always moved</strong> to another
                    location and will follow the <em>ownership</em> rules.</p>

                <h2 id="ownership"><a class="header-link" href="#ownership"><i class="fa fa-link"></i></a>Ownership</h2>

                <p>Ownership rules ensure, that at any point, for a single non-copyable
                    value, there is only one owner that can <strong>change</strong> it.</p>

                <p>Therefore, if a function is responsible for deleting this value,
                    it can be sure that there are no other users that will try to
                    access, change or delete it in future.</p>

                <p>But enough of this abstract stuff, let’s get into some real examples!</p>

                <h3 id="say-hello-to-bob-our-brave-new-dummy-structure"><a class="header-link" href="#say-hello-to-bob-our-brave-new-dummy-structure"><i class="fa fa-link"></i></a>Say hello to Bob, our brave new dummy structure</h3>

                <p>To demonstrate how the data is moving around, we will create
                    a new struct and call it <code>Bob</code>.</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">Bob</span> <span class="p">{</span>
                    <span class="n">name</span><span class="o">:</span> <span class="n">String</span><span class="p">,</span>
                    <span class="p">}</span></code></pre></div>

                <p>In Bob constructor <code>new</code>, we will announce that it was created:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Bob</span> <span class="p">{</span>
                    <span class="k">fn</span> <span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="o">:</span> <span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bob</span> <span class="p">{</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"new bob {:?}"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span> <span class="c1">// announce</span>
                    <span class="n">Bob</span> <span class="p">{</span> <span class="n">name</span><span class="o">:</span> <span class="n">name</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span> <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="p">}</span></code></pre></div>

                <p>When Bob gets destroyed (sorry, Bob!), we will print its name
                    by implementing built-in <code>Drop::drop</code> trait method:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Bob</span> <span class="p">{</span>
                    <span class="k">fn</span> <span class="nb">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"del bob {:?}"</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="p">}</span></code></pre></div>

                <p>And to make bob value format-able when outputing to console,
                    we will implement the built-in <code>Show::fmt</code> trait method:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">fmt</span><span class="o">::</span><span class="n">Show</span> <span class="k">for</span> <span class="n">Bob</span> <span class="p">{</span>
                    <span class="k">fn</span> <span class="n">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">fmt</span><span class="o">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fmt</span><span class="o">::</span><span class="nb">Result</span> <span class="p">{</span>
                    <span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"bob {:?}"</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">}</span>
                    <span class="p">}</span></code></pre></div>

                <h3 id="lets-put-it-to-the-test"><a class="header-link" href="#lets-put-it-to-the-test"><i class="fa fa-link"></i></a>Let’s put it to the Test!</h3>

                <p>When we create Bob in the <code>main</code> function, we get a predictable
                    result:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob "A"
    del bob "A"
</code></pre>

                <p>OK, it got deleted somehow - but when exactly?</p>

                <p>Let’s insert a “print” statement at the end of function:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"end is near"</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob "A"
    del bob "A"
    end is near
</code></pre>

                <p>It was deleted <strong>before</strong> the end of function. The return
                    value was not assigned to anything, so the compiler called our
                    <code>drop</code> and destroyed the value right there.</p>

                <p>What if we bind the returned value to a variable?</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"end is near"</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob "A"
    end is near
    del bob "A"
</code></pre>

                <p>With <code>let</code>, it was deleted <strong>at the end</strong> of function - at the
                    end of variable scope. So the compiler simply <strong>destroys
                        bound values at the end of scope</strong>.</p>

                <h3 id="destroyed-unless-moved"><a class="header-link" href="#destroyed-unless-moved"><i class="fa fa-link"></i></a>Destroyed Unless Moved</h3>

                <p>There is a catch though - the values can be <strong>moved</strong>
                    somewhere else - and if they get moved, they won’t get destroyed!</p>

                <p>How to move them? Well, simply pass them <strong>as values</strong> to
                    another function.</p>

                <p>Let’s pass our bob value to a function named <code>black_hole</code>:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">black_hole</span><span class="p">(</span><span class="n">bob</span><span class="o">:</span> <span class="n">Bob</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"imminent shrinkage {:?}"</span><span class="p">,</span> <span class="n">bob</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="n">black_hole</span><span class="p">(</span><span class="n">bob</span><span class="p">);</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"end is near"</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob "A"
    imminent shrinkage bob "A"
    del bob "A"
    end is near
</code></pre>

                <p><a href="http://is.gd/hOd53m">Try it yourself!</a></p>

                <p>It got destroyed in the black hole, and not at the end of <code>main</code>!</p>

                <p>But wait… What happens if we try to send <code>Bob</code> to the black hole
                    twice?</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="n">black_hole</span><span class="p">(</span><span class="n">bob</span><span class="p">);</span>
                    <span class="n">black_hole</span><span class="p">(</span><span class="n">bob</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>&lt;anon&gt;:35:16: 35:19 error: use of moved value: `bob`
    &lt;anon&gt;:35     black_hole(bob);
    ^~~
    &lt;anon&gt;:34:16: 34:19 note: `bob` moved here because it has type `Bob`, which is non-copyable
    &lt;anon&gt;:34     black_hole(bob);
    ^~~
</code></pre>

                <p>Simple! Compiler makes sure that we can not use moved values,
                    and explains nicely what happened.</p>

                <h3 id="there-is-no-magic---just-some-rules"><a class="header-link" href="#there-is-no-magic---just-some-rules"><i class="fa fa-link"></i></a>There is no Magic - just some rules</h3>

                <p>To implement “memory safety without garbage collection”, compiler
                    does not need to go chasing your values around the code. It can
                    decide what is destroyed in a function simply by <em>looking</em>
                    at the function body.</p>

                <p>You can easily do that too, if you know the rules. So far, we saw
                    a <strong>few</strong> of them:</p>

                <ul>
                    <li><strong>Unused return values are destroyed</strong>.</li>
                    <li><strong>All values bound with <code>let</code> are destroyed at the end of
                        function, unless they are moved</strong>.</li>
                </ul>

                <p>Here you go, memory safety based on the fact that there can only be
                    a single owner of a value.</p>

                <p>However, so far we talked only about <strong>immutable</strong> <code>let</code> binding -
                    the rules get slightly more complicated when the value
                    can be <em>changed</em>.</p>

                <h2 id="mutable-ownership"><a class="header-link" href="#mutable-ownership"><i class="fa fa-link"></i></a>Mutable Ownership</h2>

                <p>All the owned values can be mutated: we just need to put them to
                    <strong>mut</strong> slot with <strong>let</strong>. For example, we can mutate some
                    part of bob, like a <code>name</code>:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="k">mut</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="n">bob</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="nb">from_str</span><span class="p">(</span><span class="s">"mutant"</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob "A"
    del bob "mutant"
</code></pre>

                <p>We created it with name “A”, but deleted a “mutant”.</p>

                <p>If we give this value to another function <code>mutate</code>, we can also
                    assign it to <code>mut</code> slot there:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">mutate</span><span class="p">(</span><span class="n">value</span><span class="o">:</span> <span class="n">Bob</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="k">mut</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                    <span class="n">bob</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="nb">from_str</span><span class="p">(</span><span class="s">"mutant"</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">mutate</span><span class="p">(</span><span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">));</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob "A"
    del bob "mutant"
</code></pre>

                <p>So, it is possible to make an owned value mutable at any time.</p>

                <p>Useful to know: the function arguments can also be upgraded to <em>mutable</em>,
                    because they are also bindable slots that work the same way as a <code>let</code> slot.
                    So function from previous example can be shortened:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">mutate</span><span class="p">(</span><span class="k">mut</span> <span class="n">value</span><span class="o">:</span> <span class="n">Bob</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// use mut directly before the arg name</span>
                    <span class="n">value</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="nb">from_str</span><span class="p">(</span><span class="s">"mutant"</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

                <h3 id="replacing-value-in-a-mutable-slot"><a class="header-link" href="#replacing-value-in-a-mutable-slot"><i class="fa fa-link"></i></a>Replacing value in a mutable slot</h3>

                <p>What happens if we try to overwrite value in a <code>mut</code> slot? Let’s see:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="k">mut</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
                    <span class="k">for</span> <span class="o">&amp;</span><span class="n">name</span> <span class="k">in</span> <span class="p">[</span><span class="s">"B"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">].</span><span class="n">iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"before overwrite"</span><span class="p">);</span>
                    <span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"after overwrite"</span><span class="p">);</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob "A"

    before overwrite
    new bob "B"
    del bob "A"
    after overwrite

    before overwrite
    new bob "C"
    del bob "B"
    after overwrite

    del bob "C"
</code></pre>

                <p>The old value gets deleted. The newly assigned value will be deleted
                    at the end of scope - unless it is moved or overwritten again.</p>

                <h3 id="mutable-ownership-rules"><a class="header-link" href="#mutable-ownership-rules"><i class="fa fa-link"></i></a>Mutable Ownership rules</h3>

                <p>So, there is one additional rule, for the mutable slots:</p>

                <ul>
                    <li>Unused return values are destroyed.</li>
                    <li>All values bound with <code>let</code> are destroyed at the end of
                        function, unless they are moved.</li>
                    <li><strong>Replaced values are destroyed</strong>.</li>
                </ul>

                <p>Kind of obvious. The point is, in Rust, we are <strong>sure</strong>
                    nothing else owns or references them - so it is possible to
                    do that.</p>

                <h2 id="the-power-of-ownership-system"><a class="header-link" href="#the-power-of-ownership-system"><i class="fa fa-link"></i></a>The power of Ownership system</h2>

                <p>These ownership rules might seem a bit limiting at first, but
                    only because we are used to a different set of rules. They
                    do not limit what is actually possible, they simply give us a
                    different foundation for building higher-level constructions.</p>

                <p>Some of these constructions are way harder to make safe in other
                    languages. Even if they are made safe, they do not necessarily
                    provide compile-time safety guarantees.</p>

                <p>We will now overview some of them, available in the standard library.</p>

                <h3 id="memory-allocation"><a class="header-link" href="#memory-allocation"><i class="fa fa-link"></i></a>Memory Allocation</h3>

                <p>So far we talked about integer-like values, that live on a <strong>stack</strong>.
                    Our test dummy <code>Bob</code> was such a value. While some popular languages can <em>also</em>
                    keep values only on a stack (<code>struct</code> in C#, or
                    value instantiation without <code>new</code> in C++), many do not.</p>

                <p>Instead, a newly constructed object instance (in many languages - with a <code>new</code>
                    operator) is created in what is called the <strong>heap</strong> memory.</p>

                <p>The heap memory has some advantages. First, it is not limited by a stack size.
                    Placing a huge structure on the a stack might simply overflow it.
                    Second, its memory location does not change, unlike the location of a stack
                    value. Every time a stack-allocated value is moved or copied, the actual
                    bits need to be copied from one place of the stack to another.
                    While it is very efficient for a small structure
                    (the values are always “nearby”), it can become slower if the structure
                    grows bigger.</p>

                <p><strong>Box</strong> solves this by moving our created value to the <strong>heap</strong>, while
                    wrapping a small pointer to the heap location on the <strong>stack</strong>.</p>

                <p>For example, we can create our <code>Bob</code> in the heap memory like this:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">));</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob A
    del bob A
</code></pre>

                <p>The type of value <code>bob</code> returned from Box::new is <code>Box&lt;Bob&gt;</code>.
                    This <em>generic</em> type makes the <code>Bob</code> lifecycle managed by this <code>Box&lt;Bob&gt;</code>
                    wrapper and deleted when the <code>Box</code> is deleted.</p>

                <p><code>Box</code> is not copyable, and follows the same ownership rules discussed
                    previously. When it reached the end of life on the stack, its destructor <code>drop</code>
                    was called, which subsequently called the <code>drop</code> on the <code>Bob</code>, as well
                    as cleaned up the memory on the heap.</p>

                <p>The triviality of this implementation is a big deal. If we compare this
                    to the solutions in other languages, they mostly do one of the two things.
                    They either leave it up to you to clean up the memory (with some horrible
                    <code>delete</code> statement someone will forget or call twice), or rely on
                    garbage collection to track memory pointers and
                    clean up memory when those pointers are no longer referenced.</p>

                <p>In Rust, ownership tracking has no runtime penalty and is ensured to be
                    correct at compile-time. This simple memory deallocation over <code>Box</code>
                    builds directly on ownership tracking, is small, safe and quite often
                    sufficient.</p>

                <p>When it is not sufficient, there are other tools that can help with that.</p>

                <h3 id="garbage-collection"><a class="header-link" href="#garbage-collection"><i class="fa fa-link"></i></a>Garbage Collection</h3>

                <p>Rust has enough low-level tools for garbage collection (GC) to be implemented as
                    a library. The simplest kind of it already exists in Rust: the
                    reference-counting GC.</p>

                <p>While reference-counting solution is small and easy to implement, it
                    is not as good as full-fledged garbage collector that we
                    have in mind when we say words “Garbage Collector”.</p>

                <p>Therefore in Rust we have a better name for it: <em>shared ownership</em>.
                    The <code>std::rc</code> library provides a way to <strong>share</strong> ownership of the
                    same value between different <code>Rc</code> <em>handles</em>. The value remains alive
                    as long as there is least one handle for it.</p>

                <p>For example, we can make a bob instance managed by <code>Rc</code> handle this way:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">rc</span><span class="o">::</span><span class="n">Rc</span><span class="p">;</span>

                    <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">));</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">bob</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob A
    Rc(bob A)
    del bob A
</code></pre>

                <p><a href="http://is.gd/LFKS2A">Try it here!</a></p>

                <p>We can change our <code>black_hole</code> function to accept <code>Rc&lt;Bob&gt;</code> and check if it is
                    destroyed by it. But instead it would be more convenient to make it
                    accept <strong>any</strong> type <code>T</code> that implements <code>Show</code> trait (so we can print it).
                    We are going to make it <em>generic</em>:</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">black_hole</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="n">where</span> <span class="n">T</span><span class="o">:</span> <span class="n">fmt</span><span class="o">::</span><span class="n">Show</span> <span class="p">{</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"imminent shrinkage {:?}"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

                <p>Works the same, and we will not need to change it for every new type change.</p>

                <p>Now, back to sending <code>Rc&lt;Bob&gt;</code> to black hole!</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">));</span>
                    <span class="n">black_hole</span><span class="p">(</span><span class="n">bob</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span> <span class="c1">// clone call</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">bob</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob A
    imminent shrinkage Rc(bob A)
    Rc(bob A)
    del bob A
</code></pre>

                <p><a href="http://is.gd/A5YrX9">Try it here!</a></p>

                <p>It survived the black hole! Great! How does this work?</p>

                <p>Once wrapped by <code>Rc</code> handle, bob will live as long as there is a live <code>Rc</code> <strong>clone</strong>
                    somewhere. <code>Rc</code> handle internally uses <code>Box</code> to place new value in heap memory,
                    together with reference count (RC).</p>

                <p>Every time a new handle clone is created (by calling <code>clone</code> on <code>Rc</code>), the RC
                    is increased, and when it reaches end of life, decreased. When
                    RC reaches zero, the object itself is dropped and memory is deallocated.</p>

                <p>Note, that <code>Rc</code> above is not mutable. If the contents of <code>Bob</code> need to be mutated,
                    it can be additionally wrapped in the <code>RefCell</code> type which allows a mutable
                    borrow of a reference to our single bob instance. In the following example
                    it will be mutated it in the <code>mutate</code> function.</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">mutate</span><span class="p">(</span><span class="n">bob</span><span class="o">:</span> <span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Bob</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">bob</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="nb">from_str</span><span class="p">(</span><span class="s">"mutant"</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">RefCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">)));</span>
                    <span class="n">mutate</span><span class="p">(</span><span class="n">bob</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">bob</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob A
    Rc(RefCell { value: bob mutant })
    del bob mutant
</code></pre>

                <p>This demonstrates how different low-level utilities can be combined to
                    achieve precisely what is needed with minimal overhead.</p>

                <p>For example, <code>Rc</code> can only be used in the same thread. But there is a
                    <code>Arc</code> type for <em>atomic</em> RC usable between threads. A
                    mutable <code>Rc</code> might create cycles when multiple objects reference each other.
                    However, <code>Rc</code> can be cloned into a <code>Weak</code> reference which does not participate
                    in reference-counting. More information can be found in the
                    <a href="http://doc.rust-lang.org/std/rc/">official documentation</a>.</p>

                <p>Most importantly, more advanced garbage collection mechanisms can (and will)
                    be implemented later, and they can be done as libraries.</p>

                <h3 id="concurrency"><a class="header-link" href="#concurrency"><i class="fa fa-link"></i></a>Concurrency</h3>

                <p>It is interesting to see how Rust changes the way we work with threads.
                    The default mode here is no data races. It is not because there are some
                    special safety walls around threads, no. In principle, you could build
                    your own threading library with similar safety properties, simply
                    because the ownership model is in itself thread-safe.</p>

                <p>Consider what happens when we send two values into a new Rust thread, a
                    <code>Bob</code> (movable) and an integer (copyable):</p>

                <div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">thread</span><span class="o">::</span><span class="n">Thread</span><span class="p">;</span>

                    <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
                    <span class="kd">let</span> <span class="n">i</span> <span class="o">:</span> <span class="kt">i64</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
                    <span class="kd">let</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">::</span><span class="n">scoped</span><span class="p">(</span><span class="n">move</span> <span class="o">||</span> <span class="p">{</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"From thread, {:?} and {:?}!"</span><span class="p">,</span> <span class="n">bob</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                    <span class="p">});</span>
                    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">"waiting for thread to end"</span><span class="p">);</span>
                    <span class="p">}</span></code></pre></div>

<pre><code>new bob A
    waiting for thread to end
    From thread, bob A and 12i64!
    del bob A
</code></pre>

                <p><a href="http://is.gd/bxhDVZ">Try it here!</a></p>

                <p>What is happening there? First, we create two values:
                    <code>bob</code> and <code>i</code>. Then we create a new thread with <code>Thread::scoped</code>
                    and pass a <em>closure</em> for it to execute. This closure is going to
                    <em>capture</em> our variables <code>bob</code> as <code>i</code> simply because it <em>uses</em> them.</p>

                <p><em>Capturing</em> means different thing for <code>bob</code> and <code>i</code>. The <code>bob</code> will get
                    <strong>moved</strong> into closure (and will not be usable outside the thread),
                    while <code>i</code> will be <strong>copied</strong> into it, and will remain usable outside
                    the thread and in the thread itself.</p>

                <p>Our current, main thread will stop and wait for spawned thread
                    to finish when the returned <code>guard</code> will reach the end of its life
                    (in this case - at the end of our <code>main</code> function).</p>

                <p>One could say that this does not change much the way we used to work
                    with threads - we know not to share same memory location
                    between threads without some kind of synchronisation. The difference
                    here is that Rust can enforce these rules at compile-time.</p>

                <p>Of course, it is possible to get returned result for <code>guard</code>,
                    as well as create <code>channels</code> for sending and receiving data
                    between threads in safe and synchronised way. More is available in
                    <a href="http://doc.rust-lang.org/std/thread/">official threading documentation</a>,
                    <a href="http://doc.rust-lang.org/std/sync/mpsc/">channel documentation</a>, and
                    <a href="http://doc.rust-lang.org/book/threads.html">the book</a>.</p>

                <h3 id="what-else"><a class="header-link" href="#what-else"><i class="fa fa-link"></i></a>What Else?</h3>

                <p>We got familiar with ownership system in Rust to the point where
                    we almost seem comfortable to jump in, browse the docs, and create
                    great and safe programs with it.</p>

                <p>But the other side was glossed over completely: the <em>borrowing system</em>.</p>

                <p>In the second part of this guide, we will learn why the borrowing
                    is needed and how best to use it.</p>

            </article>

        </div>
    </div>
</div>

<footer class="site-footer">

    <div class="wrapper">

        <div class="footer-col-wrapper">
            <div class="footer-col  footer-col-1">
                <ul class="contact-list">
                    <!--<li>我</li>-->
                    <li><a href="mailto:nercury@gmail.com">gongxufan@126.com</a></li>
                </ul>
            </div>

         <!--   <div class="footer-col  footer-col-2">
                <ul class="social-media-list">

                    <li>
                        <a href="https://github.com/gongxufan">
              <span class="icon  icon&#45;&#45;github">
                <svg viewBox="0 0 16 16">
                    <path fill="#828282"
                          d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                </svg>
              </span>

                            <span class="username">gongxufan</span>
                        </a>
                    </li>

                    &lt;!&ndash;
                                        <li>
                                            <a href="https://twitter.com/nercury">
                                  <span class="icon  icon&#45;&#45;twitter">
                                    <svg viewBox="0 0 16 16">
                                        <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                                      c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                    </svg>
                                  </span>

                                                <span class="username">nercury</span>
                                            </a>
                                        </li>&ndash;&gt;

                </ul>
            </div>-->

            <div class="footer-col  footer-col-3">
                <p class="text">力量源自厚积薄发．．．
                </p>
            </div>
        </div>

    </div>

</footer>


<div id="window-resizer-tooltip" style="display: none;"><a href="#" title="Edit settings"></a><span
        class="tooltipTitle">Window size: </span><span class="tooltipWidth" id="winWidth">1600</span> x <span
        class="tooltipHeight" id="winHeight">871</span><br><span class="tooltipTitle">Viewport size: </span><span
        class="tooltipWidth" id="vpWidth">1067</span> x <span class="tooltipHeight" id="vpHeight">100</span></div>
</body>
</html>